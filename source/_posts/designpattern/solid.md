---
title:  SOLID 原則
date: 2022-09-15 13:58:10
tags: 
- C#
- oop
- Solid
categories: 
- C#
- Solid
---

# 前言
SOLID 是5大原則的簡稱，分別為：
S = Single-responsibility principle (SRP) = 單一職責原則
O = Open–closed principle (OCP) = 開放封閉原則
L =Liskov substitution principle (LSP) = 里氏替換原則
I = Interface segregation principle (ISP) = 介面隔離原則
D = Dependency inversion principle (DIP) = 依賴反向原則

<!--more-->
# 單一職責原則(SRP)
所謂單一職責就是一個類別只負責做同類型的事情。

>例:車子控制模組只負責控制車子的功能項目，如前進、後退、左右、煞車、開啟冷氣....等等，並不會去改變車子的大小或是顏色

# 開放封閉原則(OCP)
物件導向最重要的就是開放(擴充)封閉(修改)原則，當軟體程式裡的耦合性太高時，就會發生改A錯B改B錯A的情況，如何避免這種事情發生，就要遵守開放封閉原則，降低程式之間的耦合性，當擴充功能時不會去動到繼承的父程式或是使用到的函示庫的程式，就可避免牽一髮動全身的情況。

>例:小明要去一家水果店買水果，原本水果店只賣蘋果、香蕉、西瓜，但小明想買草莓時，這時就會有需要進草莓(擴充)來賣的需求，在不修改賣其他的蘋果、香蕉、西瓜(封閉修改)的功能下。

# 里氏替換原則(LSP) 
在一個系統中的物件，在不改變程式的正確性的前提下被它的子類別所替換的概念。

>例:父類別為car有個功能為(run)，子類別繼承父類別，子類別分別為:跑車、樂高積木車子、電動車，此時小強要開一台去超市買菜，選中了樂高積木的車子，但積木車沒辦法在run，這種情況就不符合Liskov替換原則，子類別應該可以執行父類別想做的事情。

# 介面隔離原則(ISP)
當用戶的需求很多時，我們可將需求分類並用各個介面完成需求，降低程式之間的耦合性

>例:開放封閉原則是大方向，介面隔離比較像實作的指示，android手機的充電孔和耳機孔兩者功能不太一樣，外型也不同，所以實際上也不會插錯，如果程式之間也使用介面(interface)方式來實作，就可避免錯誤使用的情況。


# 依賴反向原則(DIP)
高階模組不應該依賴低階模組，兩個都應該依賴在抽象概念上，抽象概念不依賴細節，而細節依賴在抽象概念上，白話文翻譯就是「話不能說的太死，盡量講一些概念性的東西」。

>例:如果依賴反轉做得好的話，你不會在意資料使用的是mysql還是mssql或是nosql及firebase等等，總之你做了一個介面，並且丟進去一個可以透過該介面撈到資料的服務。